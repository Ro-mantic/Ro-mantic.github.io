<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEI x SPACE</title>
  
  
  <link href="https://weiiup.top/atom.xml" rel="self"/>
  
  <link href="https://weiiup.top/"/>
  <updated>2023-02-10T15:57:34.757Z</updated>
  <id>https://weiiup.top/</id>
  
  <author>
    <name>Ro-mantic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL学习</title>
    <link href="https://weiiup.top/2023/01/09/MySQL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://weiiup.top/2023/01/09/MySQL%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-09T08:03:49.000Z</published>
    <updated>2023-02-10T15:57:34.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习MySQL数据库？">为什么要学习MySQL数据库？</h2><p>​在现实生活中，用户在保存数据的时候，需要将其写入文件中，然而随着程序复杂度不断提高，数据量大幅度增加，这时，如果其他人想用复用你的数据的话，就会显得尤为复杂，效率也会很低。</p><p>​因此，为了解决这种问题，数据库出现了。用户不需要管理自己的数据，只需要通过数据库软件所提供的接口来进行读写数据，这大大方便了用户进行检索与访问。</p><p>​与此同时，数据库也可以满足用户对安全的考虑，可以有效地保证数据的一致性及完整性，大大降低了数据的冗余性。🤓</p><span id="more"></span><h2 id="基础篇">基础篇</h2><h3 id="SQL">SQL</h3><p>​在使用MySQL的时候，需要用到SQL语句，因此，首先需要学习各种SQL语句，并将其记住方便今后使用。</p><h4 id="SQL通用语法">SQL通用语法</h4><ol><li><p>SQL语句可单行或多行书写，且结尾必须以分号结束语句。</p></li><li><p>数据库的SQL语句不区分大小写，但关键字建议使用大写。</p></li><li><p>注释：</p><p>单行注释：-- 内容 或 # 内容</p><p>多行注释：/* 内容 */</p></li></ol><h4 id="SQL语句分类">SQL语句分类</h4><ol><li><p>数据库查询语言（DQL）</p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块，简称DQL</p></li><li><p>数据库操作语言（DML）</p><p>用户通过它可实现对数据库的基本操作，简称DML</p></li><li><p>数据库定义语言（DDL）</p><p>数据定义语言DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词等，简称DDL。与DML相比，DML是修改数据库表中的数据，而DDL是修改数据中表的结构。</p></li><li><p>事务控制语言（TCL）</p><p>TCL常被用于快速原型开发、脚本编程、GUI和测试等方面，简称TCL</p></li><li><p>数据控制语言（DCL）</p><p>用来授予或访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。</p></li></ol><p>（学习过程中 推荐使用图形化MySQL管理软件：SQLyog）</p><h4 id="DDL">DDL</h4><h5 id="数据库操作">数据库操作</h5><p>1）、查询所有数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301202144886.png" alt="image-20230120214355786" style="zoom: 50%;" /><p>2）、查询当前的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><p>3）、创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301202149307.png" alt="image-20230120214907285" style="zoom:50%;" /><blockquote><p>若该数据库已创建，在不添加 if not exists 的情况下 会报错</p></blockquote><p>错误代码： 1007<br>Can’t create database ‘shit’; database exists</p><p>注：若数据库名为关键词，采用==`数据库名`==</p><p>4）、删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exits] 数据库名;</span><br></pre></td></tr></table></figure><p>5）、切换数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h5 id="查询创建">查询创建</h5><p>1）、查询当前数据库的所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use sys;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301231956986.png" alt="image-20230123195618896" style="zoom: 33%;" /><p>2）、查看表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301232014502.png" alt="image-20230123201421478" style="zoom: 33%;" /><p>3）、创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [ COMMENT 字段1注释 ],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释 ],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释 ],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301232016978.png" alt="image-20230123201609950" style="zoom:33%;" /><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301232016041.png" alt="image-20230123201632019" style="zoom: 50%;" /><p>注：最后一个字段无逗号</p><p>4）、查询表的建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure><h5 id="数据类型">数据类型</h5><p>MySQL中有多种数据类型，主要有三种：数值类型、字符串类型、日期时间类型。</p><p>1）、数值类型</p><p>​a. 整数类型</p><p>在MySQL数据库中，根据整数数值范围的不同，被分为五种</p><p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301252116954.png" alt="image-20230125211624861"></p><p>​b. 浮点数类型和定点数类型</p><p>MySQL数据库中，浮点数和定点数用于存储小数</p><p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202301252118165.png" alt="image-20230125211853114"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如:</span><br><span class="line">1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大</span><br><span class="line">age tinyint unsigned</span><br><span class="line">2). 分数 -- 总分100分, 最多出现一位小数</span><br><span class="line">score double(4,1)</span><br></pre></td></tr></table></figure></blockquote><p>2）、字符串类型</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">存储范围</th></tr></thead><tbody><tr><td style="text-align:center">CHAR</td><td style="text-align:center">0 ~ 255 字节</td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">0 ~ 65535 字节</td></tr><tr><td style="text-align:center">TINYBLOB</td><td style="text-align:center">0 ~ 255 字节</td></tr><tr><td style="text-align:center">TINYTEXT</td><td style="text-align:center">0 ~ 255 字节</td></tr><tr><td style="text-align:center">BLOB</td><td style="text-align:center">0 ~ 65535 字节</td></tr><tr><td style="text-align:center">TEXT</td><td style="text-align:center">0 ~ 65535 字节</td></tr><tr><td style="text-align:center">MEDIUMBLOB</td><td style="text-align:center">0 ~ 16777215 字节</td></tr><tr><td style="text-align:center">MEDIUMTEXT</td><td style="text-align:center">0 ~ 16777215 字节</td></tr><tr><td style="text-align:center">LONGBLOB</td><td style="text-align:center">0 ~ 4294967295 字节</td></tr><tr><td style="text-align:center">LONGTEXT</td><td style="text-align:center">0 ~ 4294967295 字节</td></tr></tbody></table><blockquote><p>CHAR 和 VARCHAR 都可以描述字符串，但CHAR 是定长字符串，规定多长，就占用多少字节，而 VARCHAR 是变长字符串，规定的长度为可占用最大空间，占用的字节数是为实际长度加1。</p></blockquote><blockquote><p>BLOB 和 TEXT 的区别在于 前者用于存储二进制数据，后者则存储正常文本数据。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">1). 用户名 username ------&gt; 长度不定, 最长不会超过50</span><br><span class="line">username varchar(50)</span><br><span class="line">2). 性别 gender ---------&gt; 存储值, 不是男,就是女</span><br><span class="line">gender char(1)</span><br></pre></td></tr></table></figure></blockquote><p>3）、日期事件类型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 至 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h5 id="修改表">修改表</h5><p>1）、添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 类型（长度） [comment 注释] [约束];</span><br></pre></td></tr></table></figure><p>如：</p><p>在emp表中添加一个名为nickname的字段</p><blockquote><p>ALTER TABLE emp ADD nickname VARCHAR(20) COMMENT ‘昵称’;</p></blockquote><p>2）、修改数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 新数据类型 (长度);</span><br></pre></td></tr></table></figure><p>3）、修改字段名和字段类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 旧字段名 新字段名 类型(长度) [ comment 注释] [ 约束 ];</span><br></pre></td></tr></table></figure><p>4）、删除字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><p>5）、修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新表名;</span><br></pre></td></tr></table></figure><h5 id="删除表">删除表</h5><p>1）、删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [ if exits ] 表名;</span><br></pre></td></tr></table></figure><p>2）、删除指定表，并重新创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure><h4 id="DML">DML</h4><h5 id="添加数据">添加数据</h5><p>1）、给指定数据添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 （字段名1，字段名2，...） values （值1，值2，...）;</span><br></pre></td></tr></table></figure><p>2）、给全部字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values （值1，值2，...）;</span><br></pre></td></tr></table></figure><p>3）、批量添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 （字段名1，字段名2，...） values （值1，值2，...），（值1，值2，...），（值1，值2，...）;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values （值1，值2，...），（值1，值2，...），（值1，值2，...）;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into employee values(3,&#x27;3&#x27;,&#x27;韦一笑&#x27;,&#x27;男&#x27;,38,&#x27;123456789012345670&#x27;,&#x27;2005-01-01&#x27;),(4,&#x27;4&#x27;,&#x27;赵敏&#x27;,&#x27;女&#x27;,18,&#x27;123456789012345670&#x27;,&#x27;2005-01-01&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应</li><li>字符串和日期型数据应该包含在引号中</li><li>插入的数据大小，应该在字段的规定范围内</li></ol></blockquote><h5 id="修改数据">修改数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update  表名 set 字段名1 = 值1 , 字段名2 = 值2 , ... [ where 条件 ];</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update employee set name = &#x27;小昭&#x27; , gender = &#x27;女&#x27; where id = 1;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p></blockquote><h5 id="删除数据">删除数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [ where 条件 ];</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>delete 语句的条件可有可无，若没有条件，则将会删除整张表的数据</li><li>delete 语句不能删除某一个字段的值（可使用update 将字段设置为null即可）</li></ol></blockquote><h4 id="DQL">DQL</h4><p>查询语句，语法结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后字段列表 order by 排序字段列表 limit 分页参数 </span><br></pre></td></tr></table></figure><h5 id="基础查询">基础查询</h5><p>1）、查询多个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1,字段2,字段3 ... from 表名;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><blockquote><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用。</p></blockquote><p>2）、字段设置别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1 [as 别名1], 字段2 [as 别名2], 字段3 [as 别名3] ... from 表名;</span><br></pre></td></tr></table></figure><blockquote><p>注：as可省略</p></blockquote><p>3）、去除重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段 from 表名;</span><br></pre></td></tr></table></figure><h5 id="条件查询">条件查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表名 where 条件;</span><br></pre></td></tr></table></figure><p>条件类型：</p><p>比较运算符：</p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302051730001.png" alt="image-20230205172957632" style="zoom: 33%;" /><p>逻辑运算符：</p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302051732594.png" alt="image-20230205173217552" style="zoom:33%;" /><p>案例：</p><ol><li>查询年龄不等于 88 的员工信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where age != 88;</span><br><span class="line">select * from emp where age &lt;&gt; 88;</span><br></pre></td></tr></table></figure><ol start="2"><li>查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where age &gt;= 15 &amp;&amp; age &lt;= 20;</span><br><span class="line">select * from emp where age &gt;= 15 and age &lt;= 20;</span><br><span class="line">select * from emp where age between 15 and 20;</span><br></pre></td></tr></table></figure><ol start="3"><li>查询年龄等于18 或 20 或 40 的员工信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where age = 18 or age = 20 or age =40;</span><br><span class="line">select * from emp where age in(18,20,40);</span><br></pre></td></tr></table></figure><ol start="4"><li>查询身份证号最后一位是X的员工信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where idcard like &#x27;%X&#x27;;</span><br><span class="line">select * from emp where idcard like &#x27;_________________X&#x27;;</span><br></pre></td></tr></table></figure><h5 id="聚合函数">聚合函数</h5><p>1）、常用聚合函数</p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302051741857.png" alt="image-20230205174144806" style="zoom:33%;" /><p>2）、语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 聚合函数(字段) from 表名;</span><br></pre></td></tr></table></figure><blockquote><p>​NULL值不参与聚合函数运算</p></blockquote><p>3）、案例</p><p>a. 统计该企业员工数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from emp; -- 统计的是总记录数</span><br></pre></td></tr></table></figure><p>b.  统计该企业员工的平均年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(age) from emp;</span><br></pre></td></tr></table></figure><p>c.  统计该企业员工的最大年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(age) from emp;</span><br></pre></td></tr></table></figure><p>d. 统计该企业员工的最小年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(age) from emp;</span><br></pre></td></tr></table></figure><p>e. 统计西安地区员工的年龄之和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(age) from emp where workaddress = &#x27;西安&#x27;;</span><br></pre></td></tr></table></figure><h5 id="分组查询">分组查询</h5><p>1）、语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selcet 字段 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</span><br></pre></td></tr></table></figure><p>2）、where 与 having 的区别</p><p>​执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组</p><p>之后对结果进行过滤。</p><p>​判断条件不同：where不能对聚合函数进行判断，而having可以。</p><blockquote><p>注意事项:</p><p>• 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p><p>• 执行顺序: where &gt; 聚合函数 &gt; having 。</p><p>• 支持多字段分组, 具体语法为 : group by columnA,columnB</p></blockquote><p>3）、案例</p><p>a. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select workaddress, count(*) address_count from emp where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure><p>b.  统计各个工作地址上班的男性及女性员工的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select workaddress, gender, count(*) &#x27;数量&#x27; from emp group by gender , workaddress;</span><br></pre></td></tr></table></figure><h5 id="排序查询">排序查询</h5><p>1）、语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表名 order by 字段1 排序方式1 , 字段2 排序方式2;</span><br></pre></td></tr></table></figure><p>2）、排序方式</p><p>​ASC : 升序(默认值)</p><p>​DESC: 降序</p><blockquote><p>注意事项：</p><p>• 如果是升序, 可以不指定排序方式ASC ;</p><p>• 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</p></blockquote><h5 id="分页查询">分页查询</h5><p>1）、语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表名 limit 起始索引,查询记录数;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>• 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。</p><p>• 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</p><p>• 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p></blockquote><h5 id="执行顺序">执行顺序</h5><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302061000563.png" alt="image-20230206100031469" style="zoom:33%;" /><h4 id="DCL">DCL</h4><h5 id="管理用户">管理用户</h5><p>1）、查询用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.user</span><br></pre></td></tr></table></figure><p>2）、创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified by &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure><p>3）、修改用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><p>4）、删除用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h5 id="权限控制">权限控制</h5><p>1）、查询权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><p>2）、授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grants 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><p>3）、撤销权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限列表 on 数据库名,表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>• 多个权限之间，使用逗号分隔</p><p>• 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p></blockquote><h3 id="函数">函数</h3><h4 id="字符串函数">字符串函数</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302061725475.png" alt="image-20230206172518403" style="zoom: 33%;" /><h4 id="数值函数">数值函数</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302061727231.png" alt="image-20230206172719173" style="zoom:33%;" /><h4 id="日期函数">日期函数</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302061727571.png" alt="image-20230206172758500" style="zoom:33%;" /><h4 id="流程函数">流程函数</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302061728937.png" alt="image-20230206172832874" style="zoom:33%;" /><h3 id="约束">约束</h3><h4 id="常用约束">常用约束</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302062130372.png" alt="image-20230206213018298" style="zoom:33%;" /><blockquote><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束</p></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_user(</span><br><span class="line">id int AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;ID唯一标识&#x27;,</span><br><span class="line">name varchar(10) NOT NULL UNIQUE COMMENT &#x27;姓名&#x27; ,</span><br><span class="line">age int check (age &gt; 0 &amp;&amp; age &lt;= 120) COMMENT &#x27;年龄&#x27; ,</span><br><span class="line">status char(1) default &#x27;1&#x27; COMMENT &#x27;状态&#x27;,</span><br><span class="line">gender char(1) COMMENT &#x27;性别&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="外键约束">外键约束</h4><p>添加外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    ...</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br></pre></td></tr></table></figure><p>删除外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure><h4 id="删除-更新行为">删除/更新行为</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302062322768.png" alt="image-20230206232234689" style="zoom:33%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure><h3 id="多表查询">多表查询</h3><h4 id="多表关系">多表关系</h4><ul><li>一对多 / 多对一</li><li>多对多</li><li>一对一</li></ul><h5 id="一对多">一对多</h5><p>案例：部门 与 员工的关系</p><p>关系：一个部门对应多个员工，一个员工对应一个部门</p><p>实现：在多的一方建立外键，指向一的一方的主键</p><h5 id="多对多">多对多</h5><p>案例：学生 与 课程的关系</p><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h5 id="一对一">一对一</h5><p>案例：用户 与 用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情放在另一张表中，以提高操作效率</p><p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h4 id="查询">查询</h4><p>合并查询（会展示所有结果，称为笛卡尔积现象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp, dept;</span><br></pre></td></tr></table></figure><p>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积的，只保留两表间关联部分的数据）</p><p>消除无效的笛卡尔积的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp, dept where emp.dept = dept.id;</span><br></pre></td></tr></table></figure><h4 id="内连接查询">内连接查询</h4><p>内连接查询的是两张表交集部分的数据</p><p>内连接的语法分为两种：隐式内连接、显式内连接</p><p>1）、隐式内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1, 表2, where 条件 ...;</span><br></pre></td></tr></table></figure><p>2）、显式内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1, [inner] join 表2, on 连接条件 ...;</span><br></pre></td></tr></table></figure><p>案例：</p><p>查询每一个员工的姓名，及关联的部门的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#隐式</span><br><span class="line">select emp.name, dept.name from emp, dept where emp.dept_id = dept.id;</span><br><span class="line">#显式</span><br><span class="line">select e.name, d.name from emp e inner join dept d on e.dept_id = d.id; </span><br></pre></td></tr></table></figure><h4 id="外连接查询">外连接查询</h4><p>1）、左外连接（查询表1(左表)的所有数据，也包含表1和表2交集部分的数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 left [outer] join 表2 on 条件 ... ;</span><br></pre></td></tr></table></figure><p>2）、右外连接（查询表2(右表)的所有数据，也包含表1和表2交集部分的数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 right [outer] join 表2 on 条件 ... ;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#左连接</span><br><span class="line">select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line">select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id; #与下面的右连接效果一样</span><br><span class="line">#右连接</span><br><span class="line">select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>​左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺</p><p>序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p></blockquote><h4 id="自连接查询">自连接查询</h4><p>自连接查询：顾名思义，就是自己连接自己，也就是把一张表连接查询多次,且必须使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表A 别名A join 表A 别名B on 条件 ...;</span><br></pre></td></tr></table></figure><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询员工及其所属领导的名字</span><br><span class="line">select a.name , b.name from emp a , emp b where a.managerid = b.id;</span><br><span class="line">#若无领导也需查出来</span><br><span class="line">select a.name &#x27;员工&#x27;, b.name &#x27;领导&#x27; from emp a left join emp b on a.managerid = b.id;</span><br></pre></td></tr></table></figure><h4 id="联合查询-union-union-all">联合查询 union/union all</h4><p>将多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表A ...</span><br><span class="line">union [all]</span><br><span class="line">select 字段列表 from 表B ...;</span><br></pre></td></tr></table></figure><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重</li></ul><h4 id="子查询">子查询</h4><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where column1 = (select column1 from t2);</span><br></pre></td></tr></table></figure><p>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT  的任何一个</p><p>根据子查询结果不同可分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置分为：</p><ul><li>WHERE之后</li><li>FROM之后</li><li>SELECT之后</li></ul><h5 id="标量子查询">标量子查询</h5><p>返回的结果是单个值（数字、字符串、日期等），最简单的形式，被称为标量子查询</p><p>常用操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;=</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">#根据销售部部门ID，查询员工信息</span><br><span class="line">select * from emp where dept = 4;</span><br><span class="line">#合并（子查询）</span><br><span class="line">select * from emp where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line">#查询xxx入职之后的员工信息</span><br><span class="line">select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure><h5 id="列子查询">列子查询</h5><p>子查询返回的结果是一列（可以是多行）</p><p>常用操作符：</p><img src="C:/Users/chJwi/AppData/Roaming/Typora/typora-user-images/image-20230208202556626.png" alt="image-20230208202556626" style="zoom:33%;" /><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的所有员工信息</span><br><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">#查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from emp where salary &gt; all ( select salary from emp where dept_id = (select id from dept where name = &#x27;财务部&#x27;) );</span><br><span class="line">#查询比研发部其中任意一人工资高的员工信息</span><br><span class="line">select * from emp where salary &gt; any ( select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;) );</span><br></pre></td></tr></table></figure><h5 id="行子查询">行子查询</h5><p>子查询返回的结果是一行（可以是多列）</p><p>常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询与&quot;xxx&quot;的薪资及直属领导相同的员工信息</span><br><span class="line">select * from emp where (salary,managerid) = (select salary, managerid from emp where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure><h5 id="表子查询">表子查询</h5><p>子查询返回的结果是多行多列</p><p>常用的操作符：IN</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询与&quot;xxx&quot;,&quot;xxx&quot;的职位和薪资相同的员工信息</span><br><span class="line">select * from emp where (job,salary) in ( select job, salary from emp where name = &#x27;xxx&#x27; or name = &#x27;xxx&#x27; );</span><br><span class="line">#查询入职日期是 &quot;YYYY-MM-DD&quot; 之后的员工信息 , 及其部门信息</span><br><span class="line">select e.*, d.* from (select * from emp where entrydate &gt; &#x27;YYYY-MM-DD&#x27;) e left join dept d on e.dept_id = d.id ;</span><br></pre></td></tr></table></figure><h3 id="事务">事务</h3><p>​事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系</p><p>统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><h4 id="控制事务">控制事务</h4><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看/设置事务提交方式 （0为手动，1为自动）</span><br><span class="line">select @@autocommit;</span><br><span class="line">set @@autocommit = 0;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure><blockquote><p>注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提</p><p>交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p></blockquote><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">start transaction 或 begin;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>转账案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">start transaction</span><br><span class="line">#查询张三余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">#张三的余额减少1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">#李四的余额增加1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">#如果正常执行完毕, 则提交事务</span><br><span class="line">commit;</span><br><span class="line">#如果执行过程中报错, 则回滚事务</span><br><span class="line">#rollback;</span><br></pre></td></tr></table></figure><h4 id="四大特性ACID">四大特性ACID</h4><ul><li>​原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h4 id="并发事务">并发事务</h4><p>脏读：一个事务读到另一个事务还没有提交的数据</p><p>不可重复读：一个事务先后读到同一条记录，但两次读取的数据不同</p><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</p><p>隔离级别：</p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302091112495.png" alt="image-20230209111217385" style="zoom:33%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看事务隔离级别</span><br><span class="line">select @@transaction_isolation;</span><br><span class="line"></span><br><span class="line">#设置事务隔离级别</span><br><span class="line">set [session | global] transaction isolation level &#123;read uncommitted | read committed | repeatable read | serializable&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：事务隔离级别越高，数据越安全，但性能越低</p></blockquote><h2 id="进阶篇">进阶篇</h2><h3 id="存储引擎">存储引擎</h3><p>MySQL体系结构：</p><p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302101944488.png" alt="image-20230210194432322"></p><ul><li>连接层</li></ul><p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案，同时，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><ul><li>服务层</li></ul><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如 过程、函数等</p><ul><li>引擎层</li></ul><p>储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信，不同的存储引擎具有不同的功能</p><ul><li>存储层</li></ul><p>主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。默认的存储引擎为InnoDB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#关于存储引擎的操作</span><br><span class="line">create table 表名 (</span><br><span class="line">字段1 字段1类型 [comment 字段1注释]</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型 [comment 字段n注释]</span><br><span class="line">) engine = InnoDB [comment 注释]</span><br><span class="line"></span><br><span class="line">#查询当前数据库的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure><h4 id="InnoDB">InnoDB</h4><p>​InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的</p><p>MySQL 存储引擎。</p><p>特点</p><ul><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性</li></ul><p>文件</p><p>​xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结</p><p>构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>查看 Mysql 变量：<br><code>show variables like 'innodb_file_per_table';</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：</p><p><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302102352969.png" alt="image-20230210235205885"></p><h4 id="MyISAM">MyISAM</h4><p>​MyISAM是MySQL早期的默认存储引擎。</p><p>特点</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件</p><p>xxx.sdi：存储表结构信息</p><p>xxx.MYD: 存储数据</p><p>xxx.MYI: 存储索引</p><h4 id="Memory">Memory</h4><p>​Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为</p><p>临时表或缓存使用。</p><p>特点</p><ul><li>内存存放</li><li>hash索引</li></ul><p>文件</p><p>xxx.sdi：存储表结构信息</p><h4 id="特点">特点</h4><img src="https://cdn.staticaly.com/gh/Ro-mantic/Img@master/img/202302102356259.png" alt="image-20230210235609194" style="zoom: 50%;" /><h4 id="选择">选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据</p><p>实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要</li></ul><p>求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操</p><p>作，那么InnoDB存储引擎是比较合适的选择。</p><ul><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完</li></ul><p>整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p><ul><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是</li></ul><p>对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p><h3 id="索引">索引</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要学习MySQL数据库？&quot;&gt;为什么要学习MySQL数据库？&lt;/h2&gt;
&lt;p&gt;​		在现实生活中，用户在保存数据的时候，需要将其写入文件中，然而随着程序复杂度不断提高，数据量大幅度增加，这时，如果其他人想用复用你的数据的话，就会显得尤为复杂，效率也会很低。&lt;/p&gt;
&lt;p&gt;​		因此，为了解决这种问题，数据库出现了。用户不需要管理自己的数据，只需要通过数据库软件所提供的接口来进行读写数据，这大大方便了用户进行检索与访问。&lt;/p&gt;
&lt;p&gt;​		与此同时，数据库也可以满足用户对安全的考虑，可以有效地保证数据的一致性及完整性，大大降低了数据的冗余性。🤓&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://weiiup.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>First</title>
    <link href="https://weiiup.top/2023/01/07/First/"/>
    <id>https://weiiup.top/2023/01/07/First/</id>
    <published>2023-01-07T03:42:05.000Z</published>
    <updated>2023-01-07T03:44:05.925Z</updated>
    
    <content type="html"><![CDATA[<p>hello world!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hello world!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://weiiup.top/2023/01/02/hello-world/"/>
    <id>https://weiiup.top/2023/01/02/hello-world/</id>
    <published>2023-01-02T13:24:41.691Z</published>
    <updated>2023-01-02T13:24:41.691Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
